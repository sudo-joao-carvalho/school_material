{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;\red25\green28\blue31;\red255\green255\blue255;}
{\*\expandedcolortbl;;\cssrgb\c12941\c14510\c16078;\cssrgb\c100000\c100000\c100000;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs34 \AppleTypeServices\AppleTypeServicesF65539 \cf2 \cb3 \expnd0\expndtw0\kerning0
//exemplo 2\cb1 \
\cb3 #include <stdio.h>\cb1 \
\cb3 #include <stdlib.h>\cb1 \
\cb3 #include <unistd.h>\cb1 \
\cb3 #include <sys/types.h>\cb1 \
\cb3 #include <sys/stat.h>\cb1 \
\cb3 #include <fcntl.h>\cb1 \
\cb3 #include <string.h>\cb1 \
\cb3 #include <sys/select.h>\cb1 \
\cb3 #include <pthread.h>\cb1 \
\cb3 #include <signal.h>\cb1 \
\
\
\cb3 void acorda(int s, siginfo_t *info, void *c) \{\cb1 \
\
\cb3 \}\cb1 \
\
\cb3 typedef struct\{\cb1 \
\cb3 \'a0int a;\cb1 \
\cb3 \'a0int b;\cb1 \
\cb3 \'a0int stop;\cb1 \
\cb3 \} TDADOS;\cb1 \
\
\
\cb3 void *imprime(void *dados)\{\cb1 \
\cb3 \'a0 \'a0 TDADOS *pdados = (TDADOS*) dados;\cb1 \
\cb3 \'a0 \'a0do\{\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 printf("Ola da thread \'a0[%d] [%d]\\n",pdados->a,pdados->b); \'a0 \'a0\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 sleep(5);\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 //scanf \'a0\cb1 \
\cb3 \'a0 \'a0 \}while(pdados->stop);\cb1 \
\cb3 \'a0 \'a0 pthread_exit(NULL);\cb1 \
\cb3 \}\cb1 \
\
\cb3 int \'a0main()\{\cb1 \
\cb3 \'a0 \'a0 struct sigaction act;\cb1 \
\cb3 \'a0 \'a0 \'a0 act.sa_sigaction = acorda;\cb1 \
\cb3 \'a0 \'a0 \'a0 act.sa_flags = SA_SIGINFO;\cb1 \
\cb3 \'a0 \'a0 \'a0 sigaction(SIGUSR1, &act, NULL);\cb1 \
\cb3 \'a0 \'a0 TDADOS val;\cb1 \
\cb3 \'a0 \'a0 int i;\cb1 \
\cb3 \'a0 \'a0 pthread_t a;\cb1 \
\cb3 \'a0 \'a0 val.a = 10;\cb1 \
\cb3 \'a0 \'a0 val.b = 20;\cb1 \
\cb3 \'a0 \'a0 val.stop = 1;\cb1 \
\cb3 \'a0 \'a0 if (pthread_create (&a,NULL,&imprime,&val)!=0)\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 return 0;\cb1 \
\cb3 \'a0 \'a0 scanf("%d",&i);\cb1 \
\cb3 \'a0 \'a0 val.stop = 0;\cb1 \
\cb3 \'a0 \'a0//pthread_kill(a, SIGUSR1);\cb1 \
\cb3 \'a0 \'a0 pthread_join(a, NULL);\cb1 \
\cb3 \}\cb1 \
\cb3 ///exemplo 3\cb1 \
\cb3 #include <stdio.h>\cb1 \
\cb3 #include <stdlib.h>\cb1 \
\cb3 #include <unistd.h>\cb1 \
\cb3 #include <sys/types.h>\cb1 \
\cb3 #include <sys/stat.h>\cb1 \
\cb3 #include <fcntl.h>\cb1 \
\cb3 #include <string.h>\cb1 \
\cb3 #include <sys/select.h>\cb1 \
\cb3 #include <pthread.h>\cb1 \
\cb3 #include <signal.h>\cb1 \
\
\
\cb3 void acorda(int s, siginfo_t *info, void *c) \{ \}\cb1 \
\
\cb3 typedef struct\{\cb1 \
\cb3 \'a0int stop;\cb1 \
\cb3 \'a0int contador;\cb1 \
\cb3 \'a0pthread_mutex_t *m;\cb1 \
\cb3 \} TDADOS;\cb1 \
\
\
\cb3 void *imprime(void * dados)\{\cb1 \
\cb3 \'a0 TDADOS *pdados = (TDADOS * ) dados;\cb1 \
\cb3 \'a0 for (int k=0;k<20000000;k++)\{\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0//inicio de uma zona critica\cb1 \
\cb3 \'a0 \'a0 \'a0 pthread_mutex_lock(pdados->m); \'a0\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 \'a0 pdados->contador++; // le da memoria , incrementa localmente e grava na memoria\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 pthread_mutex_unlock(pdados->m);\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0//fim de uma zona critica\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 fflush(stdout);\cb1 \
\cb3 \'a0 \'a0 \'a0\cb1 \
\cb3 \'a0 \} \'a0 \'a0\cb1 \
\cb3 \'a0 //printf("[%d]",pdados->contador);\cb1 \
\cb3 \'a0 pthread_exit(NULL);\cb1 \
\cb3 \}\cb1 \
\
\cb3 int \'a0main()\{\cb1 \
\cb3 \'a0 \'a0 int i;\cb1 \
\cb3 \'a0 \'a0 pthread_t t[20];\cb1 \
\cb3 \'a0 \'a0 pthread_mutex_t \'a0mutex; \'a0\cb1 \
\cb3 \'a0 \'a0 pthread_mutex_init(&mutex, NULL); //inicializar\cb1 \
\cb3 \'a0 \'a0 TDADOS dados;\cb1 \
\cb3 \'a0 \'a0 dados.m = &mutex;\cb1 \
\cb3 \'a0 \'a0 dados.contador = 0;\cb1 \
\cb3 \'a0 \'a0 for (i=0;i<2;i++)\cb1 \
\cb3 \'a0 \'a0 \'a0 if (pthread_create (&t[i],NULL,&imprime,&dados)!=0)\cb1 \
\cb3 \'a0 \'a0 \'a0 return -1; \'a0\cb1 \
\cb3 \'a0 \'a0 \'a0for (i=0;i<2;i++)\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0if (pthread_join(t[i], NULL)!=0)\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0return -1;\cb1 \
\cb3 \'a0 \'a0 \'a0pthread_mutex_destroy(&mutex);\cb1 \
\cb3 \'a0 \'a0 \'a0printf("\\n[%d]",dados.contador);\cb1 \
\cb3 \'a0 \'a0 \'a0\cb1 \
\cb3 \}\
\
COM MUTEX\
\
\pard\pardeftab720\partightenfactor0
\cf2 #include <stdio.h>\cb1 \
\cb3 #include <stdlib.h>\cb1 \
\cb3 #include <unistd.h>\cb1 \
\cb3 #include <sys/types.h>\cb1 \
\cb3 #include <sys/stat.h>\cb1 \
\cb3 #include <fcntl.h>\cb1 \
\cb3 #include <string.h>\cb1 \
\cb3 #include <sys/select.h>\cb1 \
\cb3 #include <pthread.h>\cb1 \
\cb3 #include <signal.h>\cb1 \
\
\cb3 typedef struct\{\cb1 \
\cb3 \'a0char tipo; \'a0\cb1 \
\cb3 \'a0int stop;\cb1 \
\cb3 \'a0pthread_mutex_t *m;\cb1 \
\cb3 \} TDADOS;\cb1 \
\
\cb3 void imprimir (char sinal,int printNumber)\{\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 for (int i=0;i<printNumber;i++)\{\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 printf("%c",sinal);\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 fflush(stdout);\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 sleep(1);\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 \}\cb1 \
\cb3 \}\cb1 \
\
\cb3 void *tarefa(void *dados)\{\cb1 \
\cb3 \'a0 \'a0 TDADOS *pdados = (TDADOS *) dados;\cb1 \
\cb3 \'a0 \'a0 while (pdados->stop)\{\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 srand(time(0)); \'a0\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 int t= rand() % (1 - 5);\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 imprimir('.',t); // imprimir os pontos\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 //inicio da zona critica\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 pthread_mutex_lock(pdados->m);\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 imprimir(pdados->tipo,3); //imprimir as letras A B\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 pthread_mutex_unlock(pdados->m);\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 //fim da zona critica\cb1 \
\
\cb3 \'a0 \'a0 \}\cb1 \
\cb3 \'a0 \'a0 pthread_exit(NULL);\cb1 \
\cb3 \}\cb1 \
\
\
\cb3 int main ()\{\cb1 \
\cb3 \'a0 \'a0 char buffer[100];\cb1 \
\cb3 \'a0 \'a0 pthread_t t[2];\cb1 \
\cb3 \'a0 \'a0 TDADOS valores[2];\cb1 \
\cb3 \'a0 \'a0 pthread_mutex_t mutex;\cb1 \
\cb3 \'a0 \'a0 pthread_mutex_init(&mutex, NULL);\cb1 \
\cb3 \'a0 \'a0 valores[0].stop = 1;\cb1 \
\cb3 \'a0 \'a0 valores[0].tipo = 'A';\cb1 \
\cb3 \'a0 \'a0 valores[0].m = &mutex;\cb1 \
\cb3 \'a0 \'a0 valores[1].stop = 1;\cb1 \
\cb3 \'a0 \'a0 valores[1].tipo = 'B';\cb1 \
\cb3 \'a0 \'a0 valores[1].m = &mutex;\cb1 \
\cb3 \'a0 \'a0 if(pthread_create(&t[0],NULL,&tarefa,&valores[0])!=0)\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 return -1;\cb1 \
\cb3 \'a0 \'a0 \'a0if(pthread_create(&t[1],NULL,&tarefa,&valores[1])!=0)\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 return -1;\cb1 \
\cb3 \'a0 \'a0 while (strcmp(buffer,"sair")!=0)\cb1 \
\cb3 \'a0 \'a0 \'a0 \'a0 scanf("%s",buffer);\cb1 \
\cb3 \'a0 \'a0 valores[0].stop = 0;\cb1 \
\cb3 \'a0 \'a0 valores[1].stop = 0;\cb1 \
\cb3 \'a0 \'a0 pthread_join(t[0], NULL);\cb1 \
\cb3 \'a0 \'a0 pthread_join(t[1], NULL);\cb1 \
\cb3 \'a0 \'a0 pthread_mutex_destroy(&mutex);\cb1 \
\cb3 \'a0 \'a0 //pthread_kill(t[0], SIGUSR1);\cb1 \
\cb3 \'a0 \'a0 return 0;\cb1 \
\cb3 \}}